{"title":"Full ERC721 Token This implementation includes all the required and some optional functionality of the ERC721 standard Moreover, it includes approve all functionality using operator terminology","fileName":"/node_modules/openzeppelin-solidity/contracts/token/ERC721/ERC721Token.sol","name":"ERC721Token","abi":[{"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_tokenId","type":"uint256"}],"name":"getApproved","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_tokenId","type":"uint256"}],"name":"approve","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_tokenId","type":"uint256"}],"name":"transferFrom","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_index","type":"uint256"}],"name":"tokenOfOwnerByIndex","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_tokenId","type":"uint256"}],"name":"safeTransferFrom","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_tokenId","type":"uint256"}],"name":"exists","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_index","type":"uint256"}],"name":"tokenByIndex","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_tokenId","type":"uint256"}],"name":"ownerOf","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_tokenId","type":"uint256"},{"name":"_data","type":"bytes"}],"name":"safeTransferFrom","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_tokenId","type":"uint256"}],"name":"tokenURI","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[{"name":"_name","type":"string"},{"name":"_symbol","type":"string"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_from","type":"address"},{"indexed":true,"name":"_to","type":"address"},{"indexed":false,"name":"_tokenId","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_owner","type":"address"},{"indexed":true,"name":"_approved","type":"address"},{"indexed":false,"name":"_tokenId","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_owner","type":"address"},{"indexed":true,"name":"_operator","type":"address"},{"indexed":false,"name":"_approved","type":"bool"}],"name":"ApprovalForAll","type":"event"}],"source":"pragma solidity ^0.4.23;\n\nimport \"./ERC721.sol\";\nimport \"./ERC721BasicToken.sol\";\n\n\n/**\n * @title Full ERC721 Token\n * This implementation includes all the required and some optional functionality of the ERC721 standard\n * Moreover, it includes approve all functionality using operator terminology\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721Token is ERC721, ERC721BasicToken {\n  // Token name\n  string internal name_;\n\n  // Token symbol\n  string internal symbol_;\n\n  // Mapping from owner to list of owned token IDs\n  mapping(address => uint256[]) internal ownedTokens;\n\n  // Mapping from token ID to index of the owner tokens list\n  mapping(uint256 => uint256) internal ownedTokensIndex;\n\n  // Array with all token ids, used for enumeration\n  uint256[] internal allTokens;\n\n  // Mapping from token id to position in the allTokens array\n  mapping(uint256 => uint256) internal allTokensIndex;\n\n  // Optional mapping for token URIs\n  mapping(uint256 => string) internal tokenURIs;\n\n  /**\n   * @dev Constructor function\n   */\n  constructor(string _name, string _symbol) public {\n    name_ = _name;\n    symbol_ = _symbol;\n  }\n\n  /**\n   * @dev Gets the token name\n   * @return string representing the token name\n   */\n  function name() public view returns (string) {\n    return name_;\n  }\n\n  /**\n   * @dev Gets the token symbol\n   * @return string representing the token symbol\n   */\n  function symbol() public view returns (string) {\n    return symbol_;\n  }\n\n  /**\n   * @dev Returns an URI for a given token ID\n   * @dev Throws if the token ID does not exist. May return an empty string.\n   * @param _tokenId uint256 ID of the token to query\n   */\n  function tokenURI(uint256 _tokenId) public view returns (string) {\n    require(exists(_tokenId));\n    return tokenURIs[_tokenId];\n  }\n\n  /**\n   * @dev Gets the token ID at a given index of the tokens list of the requested owner\n   * @param _owner address owning the tokens list to be accessed\n   * @param _index uint256 representing the index to be accessed of the requested tokens list\n   * @return uint256 token ID at the given index of the tokens list owned by the requested address\n   */\n  function tokenOfOwnerByIndex(\n    address _owner,\n    uint256 _index\n  )\n    public\n    view\n    returns (uint256)\n  {\n    require(_index < balanceOf(_owner));\n    return ownedTokens[_owner][_index];\n  }\n\n  /**\n   * @dev Gets the total amount of tokens stored by the contract\n   * @return uint256 representing the total amount of tokens\n   */\n  function totalSupply() public view returns (uint256) {\n    return allTokens.length;\n  }\n\n  /**\n   * @dev Gets the token ID at a given index of all the tokens in this contract\n   * @dev Reverts if the index is greater or equal to the total number of tokens\n   * @param _index uint256 representing the index to be accessed of the tokens list\n   * @return uint256 token ID at the given index of the tokens list\n   */\n  function tokenByIndex(uint256 _index) public view returns (uint256) {\n    require(_index < totalSupply());\n    return allTokens[_index];\n  }\n\n  /**\n   * @dev Internal function to set the token URI for a given token\n   * @dev Reverts if the token ID does not exist\n   * @param _tokenId uint256 ID of the token to set its URI\n   * @param _uri string URI to assign\n   */\n  function _setTokenURI(uint256 _tokenId, string _uri) internal {\n    require(exists(_tokenId));\n    tokenURIs[_tokenId] = _uri;\n  }\n\n  /**\n   * @dev Internal function to add a token ID to the list of a given address\n   * @param _to address representing the new owner of the given token ID\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n   */\n  function addTokenTo(address _to, uint256 _tokenId) internal {\n    super.addTokenTo(_to, _tokenId);\n    uint256 length = ownedTokens[_to].length;\n    ownedTokens[_to].push(_tokenId);\n    ownedTokensIndex[_tokenId] = length;\n  }\n\n  /**\n   * @dev Internal function to remove a token ID from the list of a given address\n   * @param _from address representing the previous owner of the given token ID\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n   */\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\n    super.removeTokenFrom(_from, _tokenId);\n\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\n    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n\n    ownedTokens[_from][tokenIndex] = lastToken;\n    ownedTokens[_from][lastTokenIndex] = 0;\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\n    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\n\n    ownedTokens[_from].length--;\n    ownedTokensIndex[_tokenId] = 0;\n    ownedTokensIndex[lastToken] = tokenIndex;\n  }\n\n  /**\n   * @dev Internal function to mint a new token\n   * @dev Reverts if the given token ID already exists\n   * @param _to address the beneficiary that will own the minted token\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n   */\n  function _mint(address _to, uint256 _tokenId) internal {\n    super._mint(_to, _tokenId);\n\n    allTokensIndex[_tokenId] = allTokens.length;\n    allTokens.push(_tokenId);\n  }\n\n  /**\n   * @dev Internal function to burn a specific token\n   * @dev Reverts if the token does not exist\n   * @param _owner owner of the token to burn\n   * @param _tokenId uint256 ID of the token being burned by the msg.sender\n   */\n  function _burn(address _owner, uint256 _tokenId) internal {\n    super._burn(_owner, _tokenId);\n\n    // Clear metadata (if any)\n    if (bytes(tokenURIs[_tokenId]).length != 0) {\n      delete tokenURIs[_tokenId];\n    }\n\n    // Reorg all tokens array\n    uint256 tokenIndex = allTokensIndex[_tokenId];\n    uint256 lastTokenIndex = allTokens.length.sub(1);\n    uint256 lastToken = allTokens[lastTokenIndex];\n\n    allTokens[tokenIndex] = lastToken;\n    allTokens[lastTokenIndex] = 0;\n\n    allTokens.length--;\n    allTokensIndex[_tokenId] = 0;\n    allTokensIndex[lastToken] = tokenIndex;\n  }\n\n}\n","abiDocs":[{"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function","details":"Gets the token name","return":"string representing the token name","signature":"name()","signatureHash":"06fdde03"},{"constant":true,"inputs":[{"name":"_tokenId","type":"uint256","description":"uint256 ID of the token to query the approval of"}],"name":"getApproved","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function","details":"Gets the approved address for a token ID, or zero if no address set","return":"address currently approved for the given token ID","signature":"getApproved(uint256)","signatureHash":"081812fc"},{"constant":false,"inputs":[{"name":"_to","type":"address","description":"address to be approved for the given token ID"},{"name":"_tokenId","type":"uint256","description":"uint256 ID of the token to be approved"}],"name":"approve","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Approves another address to transfer the given token IDThe zero address indicates there is no approved address.There can only be one approved address per token at a given time.Can only be called by the token owner or an approved operator.","signature":"approve(address,uint256)","signatureHash":"095ea7b3"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","details":"Gets the total amount of tokens stored by the contract","return":"uint256 representing the total amount of tokens","signature":"totalSupply()","signatureHash":"18160ddd"},{"constant":false,"inputs":[{"name":"_from","type":"address","description":"current owner of the token"},{"name":"_to","type":"address","description":"address to receive the ownership of the given token ID"},{"name":"_tokenId","type":"uint256","description":"uint256 ID of the token to be transferred"}],"name":"transferFrom","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Transfers the ownership of a given token ID to another addressUsage of this method is discouraged, use `safeTransferFrom` whenever possibleRequires the msg sender to be the owner, approved, or operator","signature":"transferFrom(address,address,uint256)","signatureHash":"23b872dd"},{"constant":true,"inputs":[{"name":"_owner","type":"address","description":"address owning the tokens list to be accessed"},{"name":"_index","type":"uint256","description":"uint256 representing the index to be accessed of the requested tokens list"}],"name":"tokenOfOwnerByIndex","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","details":"Gets the token ID at a given index of the tokens list of the requested owner","return":"uint256 token ID at the given index of the tokens list owned by the requested address","signature":"tokenOfOwnerByIndex(address,uint256)","signatureHash":"2f745c59"},{"constant":false,"inputs":[{"name":"_from","type":"address","description":"current owner of the token"},{"name":"_to","type":"address","description":"address to receive the ownership of the given token ID"},{"name":"_tokenId","type":"uint256","description":"uint256 ID of the token to be transferred"}],"name":"safeTransferFrom","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Safely transfers the ownership of a given token ID to another addressIf the target address is a contract, it must implement `onERC721Received`, which is called upon a safe transfer, and return the magic value `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise, the transfer is reverted.Requires the msg sender to be the owner, approved, or operator","signature":"safeTransferFrom(address,address,uint256)","signatureHash":"42842e0e"},{"constant":true,"inputs":[{"name":"_tokenId","type":"uint256","description":"uint256 ID of the token to query the existence of"}],"name":"exists","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function","details":"Returns whether the specified token exists","return":"whether the token exists","signature":"exists(uint256)","signatureHash":"4f558e79"},{"constant":true,"inputs":[{"name":"_index","type":"uint256","description":"uint256 representing the index to be accessed of the tokens list"}],"name":"tokenByIndex","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","details":"Gets the token ID at a given index of all the tokens in this contractReverts if the index is greater or equal to the total number of tokens","return":"uint256 token ID at the given index of the tokens list","signature":"tokenByIndex(uint256)","signatureHash":"4f6ccce7"},{"constant":true,"inputs":[{"name":"_tokenId","type":"uint256","description":"uint256 ID of the token to query the owner of"}],"name":"ownerOf","outputs":[{"name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function","details":"Gets the owner of the specified token ID","return":"owner address currently marked as the owner of the given token ID","signature":"ownerOf(uint256)","signatureHash":"6352211e"},{"constant":true,"inputs":[{"name":"_owner","type":"address","description":"address to query the balance of"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function","details":"Gets the balance of the specified address","return":"uint256 representing the amount owned by the passed address","signature":"balanceOf(address)","signatureHash":"70a08231"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function","details":"Gets the token symbol","return":"string representing the token symbol","signature":"symbol()","signatureHash":"95d89b41"},{"constant":false,"inputs":[{"name":"_to","type":"address","description":"operator address to set the approval"},{"name":"_approved","type":"bool","description":"representing the status of the approval to be set"}],"name":"setApprovalForAll","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Sets or unsets the approval of a given operatorAn operator is allowed to transfer all tokens of the sender on their behalf","signature":"setApprovalForAll(address,bool)","signatureHash":"a22cb465"},{"constant":false,"inputs":[{"name":"_from","type":"address","description":"current owner of the token"},{"name":"_to","type":"address","description":"address to receive the ownership of the given token ID"},{"name":"_tokenId","type":"uint256","description":"uint256 ID of the token to be transferred"},{"name":"_data","type":"bytes","description":"bytes data to send along with a safe transfer check"}],"name":"safeTransferFrom","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function","details":"Safely transfers the ownership of a given token ID to another addressIf the target address is a contract, it must implement `onERC721Received`, which is called upon a safe transfer, and return the magic value `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise, the transfer is reverted.Requires the msg sender to be the owner, approved, or operator","signature":"safeTransferFrom(address,address,uint256,bytes)","signatureHash":"b88d4fde"},{"constant":true,"inputs":[{"name":"_tokenId","type":"uint256","description":"uint256 ID of the token to query"}],"name":"tokenURI","payable":false,"stateMutability":"view","type":"function","details":"Returns an URI for a given token IDThrows if the token ID does not exist. May return an empty string.","signature":"tokenURI(uint256)","signatureHash":"c87b56dd"},{"constant":true,"inputs":[{"name":"_owner","type":"address","description":"owner address which you want to query the approval of"},{"name":"_operator","type":"address","description":"operator address which you want to query the approval of"}],"name":"isApprovedForAll","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"view","type":"function","details":"Tells whether an operator is approved by a given owner","return":"bool whether the given operator is approved by the given owner","signature":"isApprovedForAll(address,address)","signatureHash":"e985e9c5"},{"inputs":[{"name":"_name","type":"string"},{"name":"_symbol","type":"string"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_from","type":"address"},{"indexed":true,"name":"_to","type":"address"},{"indexed":false,"name":"_tokenId","type":"uint256"}],"name":"Transfer","type":"event","signature":"Transfer(address,address,uint256)","signatureHash":"ddf252ad"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_owner","type":"address"},{"indexed":true,"name":"_approved","type":"address"},{"indexed":false,"name":"_tokenId","type":"uint256"}],"name":"Approval","type":"event","signature":"Approval(address,address,uint256)","signatureHash":"8c5be1e5"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_owner","type":"address"},{"indexed":true,"name":"_operator","type":"address"},{"indexed":false,"name":"_approved","type":"bool"}],"name":"ApprovalForAll","type":"event","signature":"ApprovalForAll(address,address,bool)","signatureHash":"17307eab"}]}
